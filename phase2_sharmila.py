# -*- coding: utf-8 -*-
"""phase2.sharmila

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fHPhmooO_zyk-zXnyCm1ZtUjuLdm3XNE
"""

pip install tensorflow opencv-python numpy pillow

import tensorflow as tf
from tensorflow.keras import layers, models
import numpy as np
import cv2
from PIL import Image
import os

# Load and preprocess MNIST data
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()
x_train = x_train[..., np.newaxis] / 255.0
x_test = x_test[..., np.newaxis] / 255.0

# Define CNN model
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax')
])

# Compile and train
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])
model.fit(x_train, y_train, epochs=5, validation_split=0.1)
model.evaluate(x_test, y_test)

# Save model
model.save("mnist_cnn_model.h5")
print("Model saved as mnist_cnn_model.h5")


# -------- Helper: Preprocess custom image --------
def preprocess_image(path):
    img = Image.open(path).convert('L')  # Convert to grayscale
    img = img.resize((28, 28))  # Resize to MNIST size
    img = np.array(img)
    img = 255 - img  # Invert: black background, white digit
    img = img / 255.0  # Normalize
    img = img.reshape(1, 28, 28, 1)
    return img


# -------- Predict from your own image --------
def predict_custom_image(image_path):
    if not os.path.exists(image_path):
        print("Image not found!")
        return
    img = preprocess_image(image_path)
    prediction = model.predict(img)
    digit = np.argmax(prediction)
    print(f"Predicted digit: {digit}")


# -------- Draw on screen and predict using OpenCV --------
def draw_and_predict():
    canvas = np.zeros((280, 280), dtype=np.uint8)

    drawing = False
    ix, iy = -1, -1

    def draw(event, x, y, flags, param):
        nonlocal drawing, ix, iy
        if event == cv2.EVENT_LBUTTONDOWN:
            drawing = True
            ix, iy = x, y
        elif event == cv2.EVENT_MOUSEMOVE and drawing:
            cv2.line(canvas, (ix, iy), (x, y), 255, 20)
            ix, iy = x, y
        elif event == cv2.EVENT_LBUTTONUP:
            drawing = False

    cv2.namedWindow('Draw Digit')
    cv2.setMouseCallback('Draw Digit', draw)

    while True:
        cv2.imshow('Draw Digit', canvas)
        key = cv2.waitKey(1)

        if key == ord('p'):  # Press 'p' to predict
            small = cv2.resize(canvas, (28, 28))
            small = 255 - small  # Invert
            norm = small / 255.0
            input_img = norm.reshape(1, 28, 28, 1)
            prediction = model.predict(input_img)
            digit = np.argmax(prediction)
            print(f"Predicted: {digit}")
        elif key == ord('c'):  # Press 'c' to clear
            canvas[:] = 0
        elif key == ord('q'):  # Press 'q' to quit
            break

    cv2.destroyAllWindows()

# ------------ Run Options ------------
# Uncomment one at a time to test

# predict_custom_image("your_digit.png")   # Replace with your image path
# draw_and_predict()                       # Draw using OpenCV window

